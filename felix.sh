#!/bin/sh

# felix.sh -  Subdomain Liveness Checker
# POSIX-compliant HTTP/HTTPS checker with color-coded output

VERSION="1.0.0"
BANNER="
 ███████╗███████╗██╗     ██╗██╗  ██╗
 ██╔════╝██╔════╝██║     ██║╚██╗██╔╝
 █████╗  █████╗  ██║     ██║ ╚███╔╝ 
 ██╔══╝  ██╔══╝  ██║     ██║ ██╔██╗ 
 ██║     ███████╗███████╗██║██╔╝ ██╗
 ╚═╝     ╚══════╝╚══════╝╚═╝╚═╝  ╚═╝
  Subdomain Liveness Checker v${VERSION}
"

# Colors for output (POSIX-compliant)
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Default values
TIMEOUT=10
DELAY=0
OUTPUT_FILE=""
STATUS_FILTER=""
VERBOSE=0
SAVE_LIVE_ONLY=0
CURRENT_TIMESTAMP=""

# Print colored status
print_status() {
    local code="$1"
    local url="$2"
    local scheme="$3"
    
    case "$code" in
        2*)
            printf "${GREEN}[✓]${NC} ${CYAN}%s${NC} ${GREEN}(%d)${NC}\n" "$scheme://$url" "$code"
            ;;
        3*)
            printf "${YELLOW}[↪]${NC} ${CYAN}%s${NC} ${YELLOW}(%d)${NC}\n" "$scheme://$url" "$code"
            ;;
        4*|5*)
            printf "${RED}[✗]${NC} ${CYAN}%s${NC} ${RED}(%d)${NC}\n" "$scheme://$url" "$code"
            ;;
        *)
            printf "[?] %s (%d)\n" "$scheme://$url" "$code"
            ;;
    esac
}

# Get HTTP status with timeout
get_http_status() {
    local url="$1"
    local scheme="$2"
    local full_url="$scheme://$url"
    
    # Use curl with timeout, follow redirects, and get only status
    local response_code
    response_code=$(curl -s -o /dev/null -w "%{http_code}" \
        --max-time "$TIMEOUT" \
        --connect-timeout "$TIMEOUT" \
        -L -H "User-Agent: Felix-Scanner/$VERSION" \
        "$full_url" 2>/dev/null)
    
    # If curl fails, check if it's a timeout or connection error
    local curl_exit=$?
    if [ $curl_exit -eq 28 ]; then
        echo "timeout"
    elif [ $curl_exit -ne 0 ]; then
        echo "error"
    else
        echo "$response_code"
    fi
}

# Check if status matches filter
match_filter() {
    local code="$1"
    
    [ -z "$STATUS_FILTER" ] && return 0
    
    # Check if code matches any in filter (comma-separated)
    echo "$STATUS_FILTER" | tr ',' '\n' | grep -q "^$code$"
    return $?
}

# Save result to file
save_result() {
    local url="$1"
    local scheme="$2"
    local code="$3"
    local output_file="$4"
    
    [ -z "$output_file" ] && return
    
    # Save only live URLs if SAVE_LIVE_ONLY is set
    if [ $SAVE_LIVE_ONLY -eq 1 ] && ! echo "$code" | grep -q '^2'; then
        return
    fi
    
    # Add timestamp if not already added for this run
    if [ -z "$CURRENT_TIMESTAMP" ]; then
        CURRENT_TIMESTAMP=$(date '+%Y-%m-%d %H:%M:%S')
        printf "# Felix Scan Results - %s\n" "$CURRENT_TIMESTAMP" >> "$output_file"
        printf "# Generated by Felix v%s\n\n" "$VERSION" >> "$output_file"
    fi
    
    printf "%s://%s [%s]\n" "$scheme" "$url" "$code" >> "$output_file"
}

# Process single subdomain
process_subdomain() {
    local subdomain="$1"
    
    # Clean the subdomain (remove http://, https://, trailing slashes)
    subdomain=$(echo "$subdomain" | sed 's#^https\?://##;s#/.*##')
    
    # Skip empty lines
    [ -z "$subdomain" ] && return
    
    # Try HTTPS first
    local https_status
    https_status=$(get_http_status "$subdomain" "https")
    
    if [ "$https_status" = "timeout" ] || [ "$https_status" = "error" ]; then
        # Fallback to HTTP
        local http_status
        http_status=$(get_http_status "$subdomain" "http")
        
        if [ "$http_status" = "timeout" ] || [ "$http_status" = "error" ]; then
            printf "[✗] ${CYAN}%s${NC} ${RED}(Failed: %s)${NC}\n" "$subdomain" "$http_status"
        elif match_filter "$http_status"; then
            print_status "$http_status" "$subdomain" "http"
            save_result "$subdomain" "http" "$http_status" "$OUTPUT_FILE"
        fi
    elif match_filter "$https_status"; then
        print_status "$https_status" "$subdomain" "https"
        save_result "$subdomain" "https" "$https_status" "$OUTPUT_FILE"
    fi
    
    # Rate limiting delay
    [ "$DELAY" -gt 0 ] && sleep "$DELAY"
}

# Show usage
show_help() {
    printf "%s\n" "$BANNER"
    printf "Usage: %s [OPTIONS] <subdomain|file>\n" "$0"
    printf "\n"
    printf "OPTIONS:\n"
    printf "  -f, --file FILE      Input file containing subdomains\n"
    printf "  -o, --out FILE       Output file to save results\n"
    printf "  -c, --code CODES     Filter by status codes (comma-separated)\n"
    printf "  -t, --timeout SEC    Connection timeout in seconds (default: 10)\n"
    printf "  -r, --rate SEC       Delay between requests in seconds\n"
    printf "  -l, --live-only      Save only live (2xx) URLs to output file\n"
    printf "  -v, --verbose        Show verbose output\n"
    printf "  -h, --help           Show this help message\n"
    printf "  -V, --version        Show version\n"
    printf "\n"
    printf "EXAMPLES:\n"
    printf "  %s example.com\n" "$0"
    printf "  %s -f subdomains.txt\n" "$0"
    printf "  %s -f subdomains.txt -o results.txt -c 200,301 -t 5\n" "$0"
    printf "  %s -f subdomains.txt --live-only --rate 0.3\n" "$0"
}

# Validate numeric input
validate_number() {
    local num="$1"
    local name="$2"
    
    # Check if it's a valid positive number (integer or decimal)
    if ! echo "$num" | grep -q '^[0-9]\+\(\.[0-9]\+\)\?$'; then
        printf "Error: %s must be a positive number\n" "$name" >&2
        exit 1
    fi
}

# Main execution
main() {
    # Handle interrupt signal
    trap 'printf "\n[*] Interrupted by user\n"; exit 1' INT TERM
    
    # Check for curl availability
    if ! command -v curl >/dev/null 2>&1; then
        printf "Error: curl is required but not installed.\n"
        printf "Install with: apt install curl   or   brew install curl\n"
        exit 1
    fi
    
    # Parse arguments
    INPUT=""
    INPUT_FILE=""
    while [ $# -gt 0 ]; do
        case "$1" in
            -h|--help)
                show_help
                exit 0
                ;;
            -V|--version)
                printf "Felix v%s\n" "$VERSION"
                exit 0
                ;;
            -f|--file)
                shift
                INPUT_FILE="$1"
                ;;
            -o|--out)
                shift
                OUTPUT_FILE="$1"
                ;;
            -c|--code)
                shift
                STATUS_FILTER="$1"
                ;;
            -t|--timeout)
                shift
                validate_number "$1" "timeout"
                TIMEOUT="$1"
                ;;
            -r|--rate)
                shift
                validate_number "$1" "delay"
                DELAY="$1"
                ;;
            -l|--live-only)
                SAVE_LIVE_ONLY=1
                ;;
            -v|--verbose)
                VERBOSE=1
                ;;
            *)
                # Assume it's a subdomain if no flag
                if [ -z "$INPUT" ] && [ -z "$INPUT_FILE" ]; then
                    INPUT="$1"
                else
                    printf "Warning: Ignoring extra argument: %s\n" "$1" >&2
                fi
                ;;
        esac
        shift
    done
    
    # Show banner
    printf "%s\n" "$BANNER"
    
    # Validate input
    if [ -z "$INPUT" ] && [ -z "$INPUT_FILE" ]; then
        printf "Error: No input provided\n"
        show_help
        exit 1
    fi
    
    # Process file input
    if [ -n "$INPUT_FILE" ]; then
        if [ ! -f "$INPUT_FILE" ]; then
            printf "Error: Input file '%s' not found\n" "$INPUT_FILE"
            exit 1
        fi
        
        if [ ! -s "$INPUT_FILE" ]; then
            printf "Error: Input file '%s' is empty\n" "$INPUT_FILE"
            exit 1
        fi
        
        # Count total lines
        TOTAL_LINES=$(wc -l < "$INPUT_FILE" | tr -d ' ')
        CURRENT=0
        
        printf "[*] Processing %s subdomains from: %s\n" "$TOTAL_LINES" "$INPUT_FILE"
        printf "[*] Timeout: %ss | Delay: %ss\n" "$TIMEOUT" "$DELAY"
        [ -n "$STATUS_FILTER" ] && printf "[*] Status filter: %s\n" "$STATUS_FILTER"
        [ -n "$OUTPUT_FILE" ] && printf "[*] Output file: %s\n" "$OUTPUT_FILE"
        printf "\n"
        
        # Clear output file if it exists
        [ -n "$OUTPUT_FILE" ] && : > "$OUTPUT_FILE"
        
        # Process each line
        while IFS= read -r line || [ -n "$line" ]; do
            CURRENT=$((CURRENT + 1))
            [ $VERBOSE -eq 1 ] && printf "[%s/%s] Checking: %s\n" "$CURRENT" "$TOTAL_LINES" "$line"
            process_subdomain "$line"
        done < "$INPUT_FILE"
        
    # Process single subdomain
    else
        printf "[*] Checking single subdomain: %s\n" "$INPUT"
        printf "[*] Timeout: %ss\n" "$TIMEOUT"
        printf "\n"
        process_subdomain "$INPUT"
    fi
    
    # Summary
    printf "\n"
    printf "[*] Scan completed\n"
    if [ -n "$OUTPUT_FILE" ] && [ -f "$OUTPUT_FILE" ]; then
        local line_count
        line_count=$(grep -c '^[^#]' "$OUTPUT_FILE" 2>/dev/null || echo "0")
        printf "[*] Results saved to: %s (%s entries)\n" "$OUTPUT_FILE" "$line_count"
    fi
}

# Run main function
main "$@"
