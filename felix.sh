#!/bin/sh

VERSION="1.0.2"

BANNER="
 ███████╗███████╗██╗     ██╗██╗  ██╗
 ██╔════╝██╔════╝██║     ██║╚██╗██╔╝
 █████╗  █████╗  ██║     ██║ ╚███╔╝
 ██╔══╝  ██╔══╝  ██║     ██║ ██╔██╗
 ██║     ███████╗███████╗██║██╔╝ ██╗
 ╚═╝     ╚══════╝╚══════╝╚═╝╚═╝  ╚═╝
  Subdomain Liveness Checker v${VERSION}
"

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
NC='\033[0m'

TIMEOUT=10
DELAY=0
OUTPUT_FILE=""
STATUS_FILTER=""
VERBOSE=0
SAVE_LIVE_ONLY=0
CURRENT_TIMESTAMP=""

print_status() {
    code="$1"
    url="$2"
    scheme="$3"
    case "$code" in
        2*) printf "${GREEN}[✓]${NC} ${CYAN}%s${NC} ${GREEN}(%s)${NC}\n" "$scheme://$url" "$code" ;;
        3*) printf "${YELLOW}[↪]${NC} ${CYAN}%s${NC} ${YELLOW}(%s)${NC}\n" "$scheme://$url" "$code" ;;
        4*|5*) printf "${RED}[✗]${NC} ${CYAN}%s${NC} ${RED}(%s)${NC}\n" "$scheme://$url" "$code" ;;
        *) printf "[?] %s (%s)\n" "$scheme://$url" "$code" ;;
    esac
}

get_http_status() {
    url="$1"
    scheme="$2"
    full_url="$scheme://$url"

    response_code=$(curl -s -o /dev/null -w "%{http_code}" \
        --max-time "$TIMEOUT" \
        --connect-timeout "$TIMEOUT" \
        -L -H "User-Agent: Felix-Scanner/$VERSION" \
        "$full_url" 2>/dev/null)
    curl_exit=$?

    if [ "$curl_exit" -eq 28 ]; then
        echo "timeout"
    elif [ "$curl_exit" -ne 0 ]; then
        echo "error"
    else
        echo "$response_code"
    fi
}

match_filter() {
    code="$1"
    [ -z "$STATUS_FILTER" ] && return 0
    echo "$STATUS_FILTER" | tr ',' '\n' | grep -qx "$code"
}

save_result() {
    url="$1"
    scheme="$2"
    code="$3"
    file="$4"

    [ -z "$file" ] && return

    if [ "$SAVE_LIVE_ONLY" -eq 1 ] && ! echo "$code" | grep -q '^2'; then
        return
    fi

    if [ -z "$CURRENT_TIMESTAMP" ]; then
        CURRENT_TIMESTAMP=$(date '+%Y-%m-%d %H:%M:%S')
        {
            printf "# Felix Scan Results - %s\n" "$CURRENT_TIMESTAMP"
            printf "# Generated by Felix v%s\n\n" "$VERSION"
        } >> "$file"
    fi

    printf "%s://%s [%s]\n" "$scheme" "$url" "$code" >> "$file"
}

process_subdomain() {
    subdomain="$1"
    subdomain=$(echo "$subdomain" | sed 's#^https\?://##;s#/.*##')
    [ -z "$subdomain" ] && return
    case "$subdomain" in \#*) return ;; esac

    https_status=$(get_http_status "$subdomain" "https")

    if [ "$https_status" = "timeout" ] || [ "$https_status" = "error" ]; then
        [ "$VERBOSE" -eq 1 ] && printf "[*] HTTPS failed, trying HTTP: %s\n" "$subdomain"

        http_status=$(get_http_status "$subdomain" "http")

        if [ "$http_status" = "timeout" ] || [ "$http_status" = "error" ]; then
            printf "${RED}[✗]${NC} ${CYAN}%s${NC} ${RED}(Failed)${NC}\n" "$subdomain"
        elif match_filter "$http_status"; then
            print_status "$http_status" "$subdomain" "http"
            save_result "$subdomain" "http" "$http_status" "$OUTPUT_FILE"
        fi
    elif match_filter "$https_status"; then
        print_status "$https_status" "$subdomain" "https"
        save_result "$subdomain" "https" "$https_status" "$OUTPUT_FILE"
    fi

    [ "$DELAY" != "0" ] && sleep "$DELAY"
}

validate_number() {
    echo "$1" | grep -Eq '^[0-9]+(\.[0-9]+)?$' || {
        printf "Error: %s must be numeric\n" "$2" >&2
        exit 1
    }
}

show_help() {
    printf "%s\n" "$BANNER"
    printf "Usage: %s [OPTIONS] <subdomain|file>\n\n" "$0"
    printf "  -f, --file FILE      Input file or - for stdin\n"
    printf "  -o, --out FILE       Output file\n"
    printf "  -c, --code CODES     Filter status codes\n"
    printf "  -t, --timeout SEC    Timeout (default: 10)\n"
    printf "  -r, --rate SEC       Delay between requests\n"
    printf "  -l, --live-only      Save only 2xx\n"
    printf "  -v, --verbose        Verbose output\n"
    printf "  -h, --help           Help\n"
    printf "  -V, --version        Version\n"
}

main() {
    trap 'printf "\n[*] Interrupted\n"; exit 130' INT TERM
    command -v curl >/dev/null 2>&1 || { printf "Error: curl not installed\n"; exit 1; }

    INPUT=""
    INPUT_FILE=""

    while [ $# -gt 0 ]; do
        case "$1" in
            -h|--help) show_help; exit 0 ;;
            -V|--version) printf "Felix v%s\n" "$VERSION"; exit 0 ;;
            -f|--file) shift; INPUT_FILE="$1" ;;
            -o|--out) shift; OUTPUT_FILE="$1" ;;
            -c|--code) shift; STATUS_FILTER="$1" ;;
            -t|--timeout) shift; validate_number "$1" timeout; TIMEOUT="$1" ;;
            -r|--rate) shift; validate_number "$1" rate; DELAY="$1" ;;
            -l|--live-only) SAVE_LIVE_ONLY=1 ;;
            -v|--verbose) VERBOSE=1 ;;
            *) [ -z "$INPUT" ] && INPUT="$1" ;;
        esac
        shift
    done

    printf "%s\n" "$BANNER"

    # Determine input source
    if [ -n "$INPUT_FILE" ]; then
        if [ "$INPUT_FILE" = "-" ]; then
            INPUT_STREAM="/dev/fd/0"
        elif [ -f "$INPUT_FILE" ]; then
            INPUT_STREAM="$INPUT_FILE"
        else
            printf "Error: Input file not found\n"
            exit 1
        fi
    elif [ -n "$INPUT" ]; then
        INPUT_STREAM=""
    else
        printf "Error: No input provided\n"
        exit 1
    fi

    [ -n "$OUTPUT_FILE" ] && : > "$OUTPUT_FILE"

    if [ -n "$INPUT_STREAM" ]; then
        while IFS= read -r line || [ -n "$line" ]; do
            process_subdomain "$line"
        done < "$INPUT_STREAM"
    elif [ -n "$INPUT" ]; then
        process_subdomain "$INPUT"
    fi

    printf "\n[*] Scan completed\n"
}

main "$@"
